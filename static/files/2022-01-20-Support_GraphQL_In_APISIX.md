# Support GraphQL In APISIX



## 背景

GraphQL 是一个开源的、面向API二创造出来的数据查询操作语言以及相应的运行环境。最初由Facebook于2012年内部开发，2015年公开发布。2018年11月7日，Facebook将GraphQL项目转移到新成立的GraphQL基金会。

你其实可以把它类比为SQL查询语句来理解。GraphQL对API中的数据提供了一套易于理解的完整描述，使得客户端能够通过自定义的描述来准确获得其所需要的数据。同时这也让API能够更加容易地随着时间推移而游刃有余，避免成为一个让人望而生畏的复杂接口。

[Apache APISIX](https://apisix.apache.org/) 是 Apache 软件基金会的顶级开源项目，也是当前最活跃的开源网关项目。作为一个动态、实时、高性能的开源 API 网关，Apache APISIX 提供了负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。

## APISIX和GraphQL

从概念上来看，APISIX是一个网关，GraphQL是一种“SQL语言”。两者所存在的领域相差实在够远，但是却又因为在如今这个大数据大流量年代，恰好能够融合在一起，这实在是一件很有趣的事情。我们接下来就主要开始聊一下这两项技术的结合。

在正式开始关于APISIX和GraphQL的讨论前，我们不妨试问一下自己两个问题，问题如下两个标题。

### 为什么APISIX上要支持GraphQL？

GraphQL对APISIX来说，本质上就是一种对上游路由的过滤方法。事实上APISIX拥有不止一种过滤路由的方法，还有RadixTree这一性能的基石。那么APISIX必须支持GraphQL的理由是什么呢？很明显GraphQL具有其自身独特的优点。

当谈起API设计的时候，人们首先会想到REST API，这个API的设计思想在提出的时候是具有革命性的，并且也适时地成为了许多客户端应用程序的绝佳选择。可是随着API设计越来越复杂，并且越来越多地依赖数据驱动，REST API遇到了以下问题：

- 当设计的API接口足够多以及日益增长的请求数量，REST的数据加载方式不再满足需求；
- 当项目进展到后期遇到业务升级的时候，不能够很好地处理旧接口以及旧字段；

而GraphQL正是为了解决这一系列REST本身设计导致的缺点而出现的。

GraphQL能够根据自己的需求只请求需要的字段，通过选择感兴趣的查询字段来减少请求次数，避免信息冗余，最终实现大幅提高效率。相比较于REST来说可以支撑更多的请求数量。

GraphQL的文档和API修改是同步进行的，其文档和代码联系紧密。GraphQL的代码修改，哪怕是一个字段、一次查询都会出发文档的自动更新。相比较于REST提供了好几个版本的API，GraphQL一直都是最新的。避免出现接口发生变更，但用户始终不更新，导致功能无法正常使用的问题。

当然GraphQL远不止上述几点，其身份验证、强类型、生态等都是适应时代的优秀能力，更多优点可以阅读这篇[文章](https://www.apollographql.com/why-graphql/)。

### 为什么GraphQL需要APISIX呢？

首先我们得再细致了解一下APISIX，知己知彼方能百战百胜。

Apache-APISIX是一个动态、实时、高性能的API网关。并且APISIX还提供了丰富的流量管理能力，比如负载均衡、动态上游、金丝雀发布、熔断、认证等等。APISIX实现了一个网关该做好的事情，且在这些事情上做到了最好，甚至多做了很多实用性的能力。

由网关方面来看，GraphQL就稍显不够用了。

### APISIX+GraphQL=共赢

此外APISIX作为网关，一套系统的门户位置，还能帮助GraphQL的性能实现更进一步的提升。APISIX支持的种种插件，可以适应不同的场景。并且APISIX可扩展的特性，意味着无限的可能性。

举个例子，APISIX可以通过限速插件，对流量进一步筛选，最后抵达GraphQL。这样的方案很明显可以进一步提高GraphQL的性能。



## 如何衔接（提一提插件的实现，简单提提radix tree，唯一可以**show code**的地方）

从技术上来讲怎么做，这个插件怎么绑定
GraphQL本来就是一个查询语言，把查询语言应用到请求里，主要是来进行匹配路由的工作。主要没有上游服务，上游服务就是任由服务，只要1980即可。点应该聚焦在APISIX中GraphQL是怎么实现的。
院生：只要说这个东西实在路由上配置的，而路由上的实现是由radix tree实现的。不要往里面展开。科普主要是对GraphQL感兴趣的人，不是对APISIX技术细节感兴趣的人。
技术科普类主要针对的是场景，**为什么要在网关上支持GraphQL，为什么要在APISIX上支持GraphQL。**

## 实现效果

限速插件+GraphQL。通过限速来对GraphQL进行一个保护。

具体限流限速到具体，

GraphQL在APISIX主要是做一种路由匹配，跟radixtree配合更多一些

对于用户提供的价值，可以用不同的field，有不同的行为，不同的限流限速，不同的上游。

可以理解为路由的指纹

网关对下游是可以进行限流限速，对上游  两种控制。



另外一个场景，用户部署了两个GraphQL server，





## 针对重要问题的解答

### 尤雨溪

> 作者：尤雨溪
> 链接：https://www.zhihu.com/question/38596306/answer/79714979
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> GraphQL 确实并没有『火起来』，我觉得是这么几个因素：
>
> \1. 要在前端爽爽地使用 GraphQL，必须要在服务端搭建符合 GraphQL spec 的接口，基本上是整个改写服务端暴露数据的方式。目前 FB 官方就只有一个 Node.js 的 reference implementation，其他语言都是社区爱好者自己搞的。另外，GraphQL 在前端如何与视图层、状态管理方案结合，目前也只有 React/Relay 这个一个官方方案。换句话说，如果你不是已经在用 Node + React 这个技术栈，引入 GraphQL 成本略高，风险也不小，这就很大程度上限制了受众。
>
> \2. GraphQL 的 field resolve 如果按照 naive 的方式来写，每一个 field 都对数据库直接跑一个 query，会产生大量冗余 query，虽然网络层面的请求数被优化了，但数据库查询可能会成为性能瓶颈，这里面有很大的优化空间，但并不是那么容易做。FB 本身没有这个问题，因为他们内部数据库这一层也是抽象掉的，写 GraphQL 接口的人不需要顾虑 query 优化的问题。
>
> \3. 这个事情到底由谁来做？GraphQL 的利好主要是在于前端的开发效率，但落地却需要服务端的全力配合。如果是小公司或者整个公司都是全栈，那可能可以做，但在很多前后端分工比较明确的团队里，要推动 GraphQL 还是会遇到各种协作上的阻力。这可能是没火起来的根本原因。