---
slug: C++的编程模块——函数（上）
title: C++的编程模块——函数（上）
authors: CheverJohn
tags: [C++]
---


C++自带一个包含函数的大型库（标准ANSI库加上多个C++类），但真正的编程乐趣在于编写自己的函数；另一方面，要提高编程效率，可以更深入地学习STL和BOOSTC++提供的功能。



## 7.1	复习函数的基本知识

来复习一下介绍过的有关函数的知识。要使用C++函数，必须完成以下工作：

- 提供函数的定义
- 提供函数原型
- 调用函数

库函数是已经定义好和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。比如说strlen()函数，可以用来确定字符串的长度。相关的标准头文件cstring包含了strlen()和其他一些与字符串相关的函数的原型。

然后还有一点要注意的是，咱们程序员在编写函数的时候，一定要注意三点——定义、提供原型、调用。

```C++
#include <iostream>

void simple();

int main(){
    using namespace std;
    cout << "main() will call the simple() function:\n";
    simple();
    cout << "main() is finished with the simple() function.\n";
    cin.get();
    return 0;
}
    


void simple(){
    using namespace std;
    cout << "I'm but a simple function.\n";
}
```

上面就是一个小例子。

### 7.1.1	定义函数

可以将函数分为两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数，其通用格式如下：

```c++
void functionName(parameterList){
	statement(s)
	return ;
}
```

其中，paramterList指定了传递给函数的参数类型和数量，本章后面将更详细地介绍该列表。可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。

对于返回值，需要注意的是，

- 如果原函数的数据类型是double但是返回的是int，返回值将会被强制转化为double
- C++对返回值的类型有一定的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针、甚至可以是结构和对象（不过我们可以将数组作为结构或对象组成部分来返回）
- 若函数包含多条返回语句（例如，它们位于不同的ifelse选项中）则函数在执行遇到的第一条返回语句后结束。



干货分享：虽然作为一名程序员不需要知道函数是怎么返回值的，但是对这个问题有所了解有助于澄清概念。

通常函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。

随后，调用程序将查看该存储单元。

返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。

函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。

在原型中提供与定义中相同的信息似乎有些多余，但这样做确实有道理。要让信差从办公室的办公桌上取走一些物品，则向信差和办公室中的同事交代自己的意图，将提高信差顺利完成这项工作的概率。

### 7.1.2	函数原型和函数调用

咱们对函数调用这个知识点是很熟悉的，但是对函数原型并不清楚，函数原型通常隐藏在include文件中。

　[函数声明](https://www.baidu.com/s?wd=函数声明&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型,函数原型描述了函数的接口。

#### 1.为什么需要原型

原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。

```C++
double volume = cube(side);
```

首先，原型告诉编译器，cube()有一个double 参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main()）将从这个位置取得返回值。由于原型指出了cube()的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。

编译器需要原型，因为这样将提高效率，让编译器在广大的文件里找有用的文件，是一件大海捞针的事儿，且编译器在搜索文件的时候将必须停止 对main()的编译。一个更严重的问题是，函数甚至可能并不在项目的文件中（C++允许将一个程序放在多个文件中，单独编译他们，然后再将它们组合起来），在这种情况下，可能导致编译器在编译main()时无权访问函数代码。如果函数位于库中，情况也将如此。

综上，避免使用函数原型的唯一办法就是，在首次使用函数之前定义它，但这并不总是可行的。

#### 2.原型的语法

函数原型是一条语句，因此必须以分号结束。获取原型的方法就是，复制函数定义中的函数头，并添加分号即可。

#### 3.原型的功能

可以极大地降低程序出错的几率。

原型应确保以下几点：

- 编译器正确处理函数返回值
- 编译器检查使用的参数数目是否正确
- 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。







#### 讲一讲参数数目不对时将发生的情况

例如，假设进行了如下调用

```C++
double z = cube();
```

如果没有函数原型，编译器将允许它通过。当函数被调用时，它将找到cube()调用存放值的位置，并使用这里的值。这个正式C语言从C++借鉴原型之前的工作方式。对于ANSI C（美国国家标准规定的C语言）来讲，原型是可选的，因此有些C语言程序正是这样工作的。但在C++中，原型是不可选。因此保证了不会发生这种错误。



接下来，我们假设提供了一个参数，但是它的类型不正确。在C语言中，这将造成奇怪的错误，例如，如果函数需要一个int值（假设占16位），而程序员传递了一个double值（假设占64位），则函数将只检查64位中的前16位，并试图将它们解释为一个int值。但是C++自动将传递的值转换为原型中指定的类型，条件是两者都是算数类型。

这个时候我来举个例子吧

```C++
#include <iostream>
void cheers(int);
double cube(double x);
int main(){
    using namespace std;
    cheers(5);
    cout << "Give me a number: ";
    double side;
    cin >> side;
    double volume = cube(side);
    cout << "A" << side << "-foot cube has a volume of ";
    cout << volume << " cubic feet.\n";
    cheers(cube(2));
    return 0;
}

void cheers(int n){
    using namespace std;
    for(int i = 0; i < n; i++){
        cout << "Cheers! ";
    cout << endl;
    }
}

double cube(double x){
    return x * x * x;
}
```

这个是C++的代码

这个代码就能够应付下述语句中两次出现的类型不匹配的情况：

```C++
cheers(cube(2));
```

代码讲解：首先程序将int的值2传递给cube()，而后者期望的是double类型。编译器注意到，cube()原型指定了一个double类型参数，因此将2转化为2.0（一个double值）。接下来cube()返回一个double值(8.0)，这个值被用作cheer()的参数。编译器将再一次检查原型，并发现cheer()要求一个int参数，因此它将返回值转换为整数8.通常原型自动将被传递的参数强制转换为期望的类型

​	自动类型转换并不能避免所有可能的错误。例如，如果将8.33E27传递给期望一个int值的函数，则这样大的值将不能正确转换为int值。当较大的类型被自动转换为较小的类型时，有些编译器将发生警告，指出这可能丢失数据。

​	仅当有意义的时候，原型才会导致类型转换。正如原型不会将整数转换为结构或指针。



在编译阶段进行的原型化被称为静态类型检查(static type checking)。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。